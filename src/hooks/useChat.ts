import { useState, useCallback } from 'react';
import { Message, Conversation } from '../types/chat';
import { apiService } from '../services/api';

export const useChat = () => {
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [currentConversationId, setCurrentConversationId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const currentConversation = conversations.find(c => c.id === currentConversationId);

  const generateConversationTitle = (firstMessage: string): string => {
    const words = firstMessage.split(' ').slice(0, 6);
    return words.join(' ') + (firstMessage.split(' ').length > 6 ? '...' : '');
  };

  const createNewConversation = useCallback((): Conversation => {
    const newConversation: Conversation = {
      id: Date.now().toString(),
      title: 'New Chat',
      messages: [],
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    
    setConversations(prev => [newConversation, ...prev]);
    setCurrentConversationId(newConversation.id);
    
    return newConversation;
  }, []);

  const sendMessage = useCallback(async (content: string) => {
    if (!content.trim() || isLoading) return;

    let conversation = currentConversation;
    
    // Create new conversation if none exists
    if (!conversation) {
      conversation = createNewConversation();
    }

    const userMessage: Message = {
      id: Date.now().toString(),
      content,
      role: 'user',
      timestamp: new Date(),
    };

    // Add user message
    setConversations(prev => 
      prev.map(c => 
        c.id === conversation!.id
          ? {
              ...c,
              messages: [...c.messages, userMessage],
              title: c.messages.length === 0 ? generateConversationTitle(content) : c.title,
              updatedAt: new Date(),
            }
          : c
      )
    );

    setIsLoading(true);

    try {
      // Add streaming message placeholder
      const aiMessageId = (Date.now() + 1).toString();
      const streamingMessage: Message = {
        id: aiMessageId,
        content: '',
        role: 'assistant',
        timestamp: new Date(),
        isStreaming: true,
      };

      setConversations(prev => 
        prev.map(c => 
          c.id === conversation!.id
            ? {
                ...c,
                messages: [...c.messages, streamingMessage],
                updatedAt: new Date(),
              }
            : c
        )
      );

      // Call RAG API
      const response = await apiService.sendMessage(content, conversation.id);

      // Update with actual response
      setConversations(prev => 
        prev.map(c => 
          c.id === conversation!.id
            ? {
                ...c,
                messages: c.messages.map(m => 
                  m.id === aiMessageId
                    ? { 
                        ...m, 
                        content: response.response, 
                        isStreaming: false,
                        sources: response.sources 
                      }
                    : m
                ),
                updatedAt: new Date(),
              }
            : c
        )
      );

      // Update conversation ID if it was generated by the backend
      if (response.conversation_id !== conversation.id) {
        setCurrentConversationId(response.conversation_id);
        setConversations(prev => 
          prev.map(c => 
            c.id === conversation!.id
              ? { ...c, id: response.conversation_id }
              : c
          )
        );
      }

    } catch (error) {
      console.error('Error getting AI response:', error);
      
      // Add error message
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: `Sorry, I encountered an error: ${error instanceof Error ? error.message : 'Unknown error'}. Please make sure documents are uploaded and try again.`,
        role: 'assistant',
        timestamp: new Date(),
      };

      setConversations(prev => 
        prev.map(c => 
          c.id === conversation!.id
            ? {
                ...c,
                messages: c.messages.filter(m => !m.isStreaming).concat(errorMessage),
                updatedAt: new Date(),
              }
            : c
        )
      );
    } finally {
      setIsLoading(false);
    }
  }, [currentConversation, isLoading, createNewConversation]);

  const selectConversation = useCallback((id: string) => {
    setCurrentConversationId(id);
  }, []);

  const deleteConversation = useCallback((id: string) => {
    setConversations(prev => prev.filter(c => c.id !== id));
    if (currentConversationId === id) {
      const remaining = conversations.filter(c => c.id !== id);
      setCurrentConversationId(remaining.length > 0 ? remaining[0].id : null);
    }
  }, [currentConversationId, conversations]);

  const startNewChat = useCallback(() => {
    createNewConversation();
  }, [createNewConversation]);

  return {
    conversations,
    currentConversation,
    currentConversationId,
    isLoading,
    sendMessage,
    selectConversation,
    deleteConversation,
    startNewChat,
  };
};